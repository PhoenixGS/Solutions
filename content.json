{"meta":{"title":"Solutions","subtitle":null,"description":null,"author":"PhoenixGS","url":"http://x.phoenixgs.cn/Solutions"},"pages":[{"title":"About","date":"2018-04-27T13:59:36.597Z","updated":"2018-04-10T07:35:55.561Z","comments":true,"path":"about/index.html","permalink":"http://x.phoenixgs.cn/Solutions/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-04-27T13:59:36.641Z","updated":"2018-04-10T07:36:14.299Z","comments":true,"path":"tags/index.html","permalink":"http://x.phoenixgs.cn/Solutions/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-04-27T13:59:36.615Z","updated":"2018-04-10T07:36:06.949Z","comments":true,"path":"categories/index.html","permalink":"http://x.phoenixgs.cn/Solutions/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"BZOJ 3163 [Heoi2013]Eden的新背包问题","slug":"BZOJ-3163","date":"2018-10-24T13:50:24.000Z","updated":"2018-10-24T13:54:29.024Z","comments":true,"path":"2018/10/24/BZOJ-3163/","link":"","permalink":"http://x.phoenixgs.cn/Solutions/2018/10/24/BZOJ-3163/","excerpt":"题解 这道题第一眼看是维护前缀后缀然后合并的，但是这样复杂度很高，据说可以水过 因此，不考虑合并。那么问题就是去掉每一个物品，做一次多重背包。这样的复杂度为\\(O(n^2m)\\)。 考虑以上算法的重复计算部分。可以发现有许多是重复计算了的。那么就可以考虑分治，因为分治可以省去许多重复计算。那么算法就显而易见了。","text":"题解 这道题第一眼看是维护前缀后缀然后合并的，但是这样复杂度很高，据说可以水过 因此，不考虑合并。那么问题就是去掉每一个物品，做一次多重背包。这样的复杂度为\\(O(n^2m)\\)。 考虑以上算法的重复计算部分。可以发现有许多是重复计算了的。那么就可以考虑分治，因为分治可以省去许多重复计算。那么算法就显而易见了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;long long read()&#123; char last = '+', ch = getchar(); while (ch &lt; '0' || ch &gt; '9') last = ch, ch = getchar(); long long tmp = 0; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') tmp = tmp * 10 + ch - 48, ch = getchar(); if (last == '-') tmp = -tmp; return tmp;&#125;const int _n = 1000 + 10, _m = 1000 + 10, _q = 300000 + 10;int n, q;int c[_n], v[_n], m[_n];int que[_m], val[_m];int f[20][_n];std::vector&lt;std::pair&lt;int, int&gt; &gt; vec[_n];int ans[_q];void update(int *f, int pos)&#123; for (int i = 0; i &lt; c[pos]; i++) &#123; int head = 1, tail = 1; que[1] = 0; val[1] = f[i]; for (int j = 1; i + c[pos] * j &lt;= 1000; j++) &#123; while (head &lt;= tail &amp;&amp; j - que[head] &gt; m[pos]) &#123; head++; &#125; while (head &lt;= tail &amp;&amp; f[i + c[pos] * j] &gt;= val[tail] + (j - que[tail]) * v[pos]) &#123; tail--; &#125; tail++; que[tail] = j; val[tail] = f[i + c[pos] * j]; f[i + c[pos] * j] = val[head] + (j - que[head]) * v[pos]; &#125; &#125;&#125;void solve(int l, int r, int d)&#123; if (l == r) &#123; for (int i = 0; i &lt; (int)vec[l].size(); i++) &#123; ans[vec[l][i].second] = f[d][vec[l][i].first]; &#125; return; &#125; int mid = (l + r) &gt;&gt; 1; for (int i = 0; i &lt;= 1000; i++) &#123; f[d + 1][i] = f[d][i]; &#125; for (int i = mid + 1; i &lt;= r; i++) &#123; update(f[d + 1], i); &#125; solve(l, mid, d + 1); for (int i = 0; i &lt;= 1000; i++) &#123; f[d + 1][i] = f[d][i]; &#125; for (int i = l; i &lt;= mid; i++) &#123; update(f[d + 1], i); &#125; solve(mid + 1, r, d + 1);&#125;int main()&#123; n = read(); for (int i = 1; i &lt;= n; i++) &#123; c[i] = read(); v[i] = read(); m[i] = read(); &#125; q = read(); for (int i = 1; i &lt;= q; i++) &#123; int pos, sum; pos = read(); sum = read(); pos++; vec[pos].push_back(std::make_pair(sum, i)); &#125; solve(1, n, 1); for (int i = 1; i &lt;= q; i++) &#123; printf(\"%d\\n\", ans[i]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://x.phoenixgs.cn/Solutions/tags/DP/"},{"name":"分治","slug":"分治","permalink":"http://x.phoenixgs.cn/Solutions/tags/分治/"}]},{"title":"HDU 4333 Revolving Digits","slug":"HDU-4333","date":"2018-04-10T06:02:55.000Z","updated":"2018-04-10T06:09:51.959Z","comments":true,"path":"2018/04/10/HDU-4333/","link":"","permalink":"http://x.phoenixgs.cn/Solutions/2018/04/10/HDU-4333/","excerpt":"题意 求所有与N循环同构的字符串中，转换成字符串后有几个比它小，相等，比它大","text":"题意 求所有与N循环同构的字符串中，转换成字符串后有几个比它小，相等，比它大 ## 题解 扩展KMP求出extend之后，只需比较下一个字符就可以了，然后输出的是本质不同的字符串的个数 ## 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int T, n;char s[200000];int nextx[200000];int ans1, ans2, ans3;int cas;int main()&#123; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", s); n = strlen(s); nextx[0] = n; int pos = -1, last = -1; for (int i = 1; i &lt; n; i++) &#123; int k = (pos == -1 || i &gt; last) ? 0 : std::min(nextx[i - pos], last - i + 1); while (k &lt; n &amp;&amp; s[k] == s[(i + k) % n]) &#123; k++; &#125; nextx[i] = k; if (i + nextx[i] - 1 &gt; last) &#123; pos = i; last = i + nextx[i] - 1; &#125; &#125; ans1 = ans2 = ans3 = 0; for (int i = 0; i &lt; n; i++) &#123; if (nextx[i] == n) &#123; ans2++; &#125; else &#123; if (s[(i + nextx[i]) % n] &gt; s[nextx[i]]) &#123; ans3++; &#125; else &#123; ans1++; &#125; &#125; &#125; cas++; printf(\"Case %d: %d %d %d\\n\", cas, ans1 / ans2, ans2 / ans2, ans3 / ans2); &#125; return 0;&#125;","categories":[],"tags":[{"name":"扩展KMP","slug":"扩展KMP","permalink":"http://x.phoenixgs.cn/Solutions/tags/扩展KMP/"}]},{"title":"51nod 1286 三段子串","slug":"51nod-1286","date":"2018-04-10T01:14:25.000Z","updated":"2018-04-10T01:21:35.685Z","comments":true,"path":"2018/04/10/51nod-1286/","link":"","permalink":"http://x.phoenixgs.cn/Solutions/2018/04/10/51nod-1286/","excerpt":"题意 给定一个字符串S，找到另外一个字符串T，T既是S的前缀，也是S的后缀，并且在中间某个地方也出现一次，并且这三次出现不重合。求T最长的长度。","text":"题意 给定一个字符串S，找到另外一个字符串T，T既是S的前缀，也是S的后缀，并且在中间某个地方也出现一次，并且这三次出现不重合。求T最长的长度。 ## 题解 跑一遍KMP和扩展KMP，然后从大到小枚举所有的T使T是S的前缀和后缀，然后维护一段区间的extend的最大值，由于T是从大到小枚举的，所以区间是从小到大的。时间复杂度$ O(n) $ ## 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int n;char s[2000000];int fail[2000000], nextx[2000000];void getfail()&#123; int j = 0; for (int i = 2; i &lt;= n; i++) &#123; while (j &amp;&amp; s[j + 1] != s[i]) &#123; j = fail[j]; &#125; if (s[j + 1] == s[i]) &#123; j++; &#125; fail[i] = j; &#125;&#125;void getnextx()&#123; nextx[1] = n; int pos = -1, last = -1; for (int i = 2; i &lt;= n; i++) &#123; int k = (pos == -1 || i &gt; last) ? 0 : std::min(nextx[i - pos + 1], last - i + 1); while (k &lt; n &amp;&amp; s[k + 1] == s[i + k]) &#123; k++; &#125; nextx[i] = k; if (i + nextx[i] - 1 &gt; last) &#123; pos = i; last = i + nextx[i] - 1; &#125; &#125;&#125;int main()&#123; scanf(\"%s\", s + 1); n = strlen(s + 1); getfail(); getnextx(); int maxx = 0; int k = fail[n]; for (; k * 3 &gt; n; k = fail[k]); int l = k + 1; int r = n - 2 * k + 1; for (int i = l; i &lt;= r; i++) &#123; maxx = std::max(maxx, nextx[i]); &#125; if (maxx &gt;= k) &#123; printf(\"%d\\n\", k); return 0; &#125; for (k = fail[k]; k; k = fail[k]) &#123; int ll = k + 1; int rr = n - 2 * k + 1; for (int i = ll; i &lt; l; i++) &#123; maxx = std::max(maxx, nextx[i]); &#125; for (int i = r + 1; i &lt;= rr; i++) &#123; maxx = std::max(maxx, nextx[i]); &#125; l = ll; r = rr; if (maxx &gt;= k) &#123; printf(\"%d\\n\", k); return 0; &#125; &#125; printf(\"0\\n\"); return 0;&#125;","categories":[],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://x.phoenixgs.cn/Solutions/tags/KMP/"},{"name":"扩展KMP","slug":"扩展KMP","permalink":"http://x.phoenixgs.cn/Solutions/tags/扩展KMP/"}]},{"title":"BZOJ 1009 [HNOI2008]GT考试","slug":"BZOJ-1009","date":"2018-04-09T02:30:51.000Z","updated":"2018-04-10T06:11:05.685Z","comments":true,"path":"2018/04/09/BZOJ-1009/","link":"","permalink":"http://x.phoenixgs.cn/Solutions/2018/04/09/BZOJ-1009/","excerpt":"题意 有多少个n位数字，其中没有出现过A","text":"题意 有多少个n位数字，其中没有出现过A ## 题解 很simple的一个DP就是f[i][j]表示现在字符串长度为i，匹配到A的KMP的状态为j，然后用矩阵乘法优化一下就好了 ## 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;cstring&gt;int n, m, M;char s[1000];int nextx[1000];int mat[22][22], ans[22][22], z[22][22];int anss;void getnextx()&#123; int j = 0; for (int i = 2; i &lt;= m; i++) &#123; while (j &amp;&amp; s[j + 1] != s[i]) &#123; j = nextx[j]; &#125; if (s[j + 1] == s[i]) &#123; j++; &#125; nextx[i] = j; &#125;&#125;void mul(int x[22][22], int y[22][22])&#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; z[i][j] = 0; &#125; &#125; for (int k = 0; k &lt; m; k++) &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; z[i][j] = (z[i][j] + (long long)x[i][k] * y[k][j] % M) % M; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; x[i][j] = z[i][j]; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;M); scanf(\"%s\", s + 1); getnextx(); for (int i = 0; i &lt; m; i++) &#123; for (char j = '0'; j &lt;= '9'; j++) &#123; int tmp = i; while (tmp &amp;&amp; s[tmp + 1] != j) &#123; tmp = nextx[tmp]; &#125; if (s[tmp + 1] == j) &#123; tmp++; &#125; if (tmp != m) &#123; mat[i][tmp]++; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; ans[i][i] = 1; &#125; while (n) &#123; if (n &amp; 1) &#123; mul(ans, mat); &#125; mul(mat, mat); n &gt;&gt;= 1; &#125; anss = 0; for (int i = 0; i &lt; m; i++) &#123; anss = (anss + ans[0][i]) % M; &#125; printf(\"%d\\n\", anss); return 0;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://x.phoenixgs.cn/Solutions/tags/DP/"},{"name":"KMP","slug":"KMP","permalink":"http://x.phoenixgs.cn/Solutions/tags/KMP/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"http://x.phoenixgs.cn/Solutions/tags/矩阵乘法/"}]},{"title":"BZOJ 3670 [Noi2014]动物园","slug":"BZOJ-3670","date":"2018-04-09T02:21:11.000Z","updated":"2018-04-27T14:08:32.730Z","comments":true,"path":"2018/04/09/BZOJ-3670/","link":"","permalink":"http://x.phoenixgs.cn/Solutions/2018/04/09/BZOJ-3670/","excerpt":"题意 我现在希望求出一个更强大num数组一一对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。 然后输出$ _ {i = 1} ^ L (num[i] + 1) $","text":"题意 我现在希望求出一个更强大num数组一一对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。 然后输出$ _ {i = 1} ^ L (num[i] + 1) $ 题解 这道题十分显然，求出nextx数组的同时求出自动机状态里的集合大小，然后枚举区间的右端点，满足题意不重叠的条件之后就可以算答案了。 ## 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int M = 1000000007;int T;int ans;char s[2000000];int n;int nextx[2000000];int k[2000000];int main()&#123; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); k[0] = 0; k[1] = 1; int j = 0; for (int i = 2; i &lt;= n; i++) &#123; while (j &amp;&amp; s[j + 1] != s[i]) &#123; j = nextx[j]; &#125; if (s[j + 1] == s[i]) &#123; j++; &#125; nextx[i] = j; k[i] = k[j] + 1; &#125; j = 0; ans = 1; for (int i = 1; i &lt;= n; i++) &#123; while (j &amp;&amp; s[j + 1] != s[i]) &#123; j = nextx[j]; &#125; if (s[j + 1] == s[i]) &#123; j++; &#125; while (j &gt; i / 2) &#123; j = nextx[j]; &#125; ans = (long long)ans * (k[j] + 1) % M; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://x.phoenixgs.cn/Solutions/tags/KMP/"}]},{"title":"HDU 2594 Simpsons’ Hidden Talents","slug":"HDU-2594","date":"2018-04-08T13:00:39.000Z","updated":"2018-04-10T01:21:40.168Z","comments":true,"path":"2018/04/08/HDU-2594/","link":"","permalink":"http://x.phoenixgs.cn/Solutions/2018/04/08/HDU-2594/","excerpt":"题意 求出最大的k使s1长度为k的前缀等于s2长度为k的后缀","text":"题意 求出最大的k使s1长度为k的前缀等于s2长度为k的后缀 ## 题解 扩展KMP模版题，求出extend之后，从前往后枚举位置i，只要往后extend[i]能到末尾就输出答案 ## 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;char s[100000], t[100000];int n, m;int nextx[100000], extend[100000];int ans;void getnextx()&#123; int pos = -1, last = -1; for (int i = 2; i &lt;= m; i++) &#123; int k = (pos == -1 || i &gt; last) ? 0 : std::min(nextx[i - pos + 1], last - i + 1); while (k + 1 &lt;= n &amp;&amp; t[i + k] == t[k + 1]) &#123; k++; &#125; nextx[i] = k; if (i + nextx[i] - 1 &gt; last) &#123; pos = i; last = i + nextx[i] - 1; &#125; &#125;&#125;int main()&#123; while (scanf(\"%s%s\", s + 1, t + 1) == 2) &#123; n = strlen(s + 1); m = strlen(t + 1); getnextx(); int pos = -1, last = -1; for (int i = 1; i &lt;= m; i++) &#123; int k = (pos == -1 || i &gt; last) ? 0 : std::min(nextx[i - pos + 1], last - i + 1); while (k + 1 &lt;= n &amp;&amp; i + k &lt;= m &amp;&amp; t[i + k] == s[k + 1]) &#123; k++; &#125; extend[i] = k; if (i + extend[i] - 1 &gt; last) &#123; pos = i; last = i + extend[i] - 1; &#125; &#125; ans = 0; for (int i = 1; i &lt;= m; i++) &#123; if (i + extend[i] - 1 == m) &#123; ans = extend[i]; break; &#125; &#125; if (ans) &#123; for (int i = 1; i &lt;= ans; i++) &#123; printf(\"%c\", s[i]); &#125; printf(\" \"); &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"扩展KMP","slug":"扩展KMP","permalink":"http://x.phoenixgs.cn/Solutions/tags/扩展KMP/"}]},{"title":"Hello World","slug":"Hello-World","date":"2016-05-29T03:07:22.000Z","updated":"2018-04-09T16:28:03.783Z","comments":true,"path":"2016/05/29/Hello-World/","link":"","permalink":"http://x.phoenixgs.cn/Solutions/2016/05/29/Hello-World/","excerpt":"","text":"123456789#include &lt;cstdio&gt;int main()&#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", x + y); return 0;&#125;","categories":[],"tags":[]}]}